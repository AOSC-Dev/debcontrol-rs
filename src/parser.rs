//! Parser implementations.
//!
//! Most of the parser implementation is generated by the `parsers` macro: since the control file
//! format is not clearly terminated, we need parsers both for partial and for complete input. When
//! streaming input, all lines must include a line terminator and paragraphs are only emitted when a
//! blank line is encountered. However, when finishing parsing a file, we need to accept lines and
//! paragraphs that just stop, without a final trailing blank line. Because of this, we generate two
//! implemenations of the basic parsers: one using the parsers from `nom::characters::streaming`
//! and `nom::bytes::streaming`, and another one using `nom::characters::complete` and
//! `nom::bytes::complete`.

use crate::Field;
use alloc::{string::String, vec::Vec};
use nom::{
    error::{make_error, ErrorKind, ParseError},
    Err::Error,
    IResult,
};

/// Return true if this character is valid in a field identifier.
fn is_field_name_char(c: char) -> bool {
    c.is_ascii_graphic() && c != ':'
}

/// Return true if this field identifier starts with a valid character.
fn starts_with_valid_char(name: &str) -> bool {
    !name.starts_with('#') && !name.starts_with('-')
}

/// Represents a field definition line.
struct FieldDefinitionLine<'a> {
    /// The field identifier.
    name: &'a str,
    /// The value on the definition line.
    ///
    /// For single-line fields, this is the entire value. For fields with continuation lines, this
    /// is just the first line of the value.
    value: &'a str,
}

/// Represents one of the lines following a field definition line.
enum FieldDefinitionContinuation<'a> {
    /// A continuation line (leading spaces followed by a non-whitespace value).
    Continuation(&'a str),
    /// A comment line (starting with '#').
    Comment,
    /// A blank line.
    Blank,
}

/// Create a `Field` from its constituent parts.
///
/// The value from the field definition and any continuation lines are concatenated using '\n'
/// characters. Comment lines are skipped over. The resulting value will never have a trailing
/// newline.
fn field_from_parts<'a>(
    parts: (
        FieldDefinitionLine<'a>,
        Vec<FieldDefinitionContinuation<'a>>,
    ),
) -> Field<'a> {
    let mut value = String::from(parts.0.value);
    for line in parts.1 {
        if let FieldDefinitionContinuation::Continuation(line) = line {
            value.push('\n');
            value.push_str(line);
        }
    }
    Field {
        name: parts.0.name,
        value,
    }
}

/// Parse the end of input.
///
/// If the input is empty, `Ok` is returned with no rest. If the input is not empty, the parser
/// errors.
fn eof<'a, E>(input: &'a str) -> IResult<&'a str, (), E>
where
    E: ParseError<&'a str>,
{
    if input.is_empty() {
        Ok((input, ()))
    } else {
        Err(Error(make_error(input, ErrorKind::Eof)))
    }
}

macro_rules! parsers {
    ($name: ident) => {
        /// Generated module for parsers.
        ///
        /// The parsers in this module are generated from a single source using a macro, to produce
        /// different parsers for partial ("streaming") and complete input.
        pub(crate) mod $name {
            use super::{
                eof, field_from_parts, is_field_name_char, starts_with_valid_char,
                FieldDefinitionContinuation, FieldDefinitionLine,
            };
            use crate::{Field, Paragraph};
            use nom::{
                branch::alt,
                bytes::$name::take_while1,
                character::$name::{char, line_ending, not_line_ending, space0, space1},
                combinator::{cut, map, opt, verify},
                error::{context, ParseError},
                multi::{many0, many0_count, many1},
                sequence::{pair, preceded, separated_pair, terminated, tuple},
                IResult,
            };

            /// Parse a field name, not including the delimiting colon.
            fn field_name<'a, E>(input: &'a str) -> IResult<&'a str, &'a str, E>
            where
                E: ParseError<&'a str>,
            {
                verify(take_while1(is_field_name_char), starts_with_valid_char)(input)
            }

            /// Parse a colon followed by zero or more whitespace characters.
            fn colon_and_whitespace<'a, E>(input: &'a str) -> IResult<&'a str, (), E>
            where
                E: ParseError<&'a str>,
            {
                map(pair(char(':'), space0), |_| ())(input)
            }

            /// Parse the value in a field definition line.
            ///
            /// This consumes all characters except for newlines, terminated by either a newline or
            /// (for complete parsers) by EOF.
            fn field_value<'a, E>(input: &'a str) -> IResult<&'a str, &'a str, E>
            where
                E: ParseError<&'a str>,
            {
                terminated(not_line_ending, opt(line_ending))(input)
            }

            /// Parse a full field definition line, consisting of a field name, colon, and a value.
            fn field_definition_line<'a, E>(
                input: &'a str,
            ) -> IResult<&'a str, FieldDefinitionLine<'a>, E>
            where
                E: ParseError<&'a str>,
            {
                map(
                    separated_pair(field_name, cut(colon_and_whitespace), cut(field_value)),
                    |(name, value)| FieldDefinitionLine { name, value },
                )(input)
            }

            /// Parse a field continuation line.
            ///
            /// This is at least one whitespace (which is dropped), followed by arbitrary characters
            /// until the end of line or (for complete parsers) EOF.
            fn continuation_line<'a, E>(
                input: &'a str,
            ) -> IResult<&'a str, FieldDefinitionContinuation<'a>, E>
            where
                E: ParseError<&'a str>,
            {
                map(preceded(space1, field_value), |value| {
                    FieldDefinitionContinuation::Continuation(value)
                })(input)
            }

            /// Parse a comment line: '#' until the end of line or EOF.
            fn comment_line<'a, E>(
                input: &'a str,
            ) -> IResult<&'a str, FieldDefinitionContinuation<'a>, E>
            where
                E: ParseError<&'a str>,
            {
                map(
                    tuple((char('#'), not_line_ending, opt(line_ending))),
                    |_| FieldDefinitionContinuation::Comment,
                )(input)
            }

            /// Parse a line consisting only of whitespace.
            fn blank_line<'a, E>(
                input: &'a str,
            ) -> IResult<&'a str, FieldDefinitionContinuation<'a>, E>
            where
                E: ParseError<&'a str>,
            {
                map(terminated(space0, line_ending), |_| {
                    FieldDefinitionContinuation::Blank
                })(input)
            }

            /// Parse a full field definition.
            ///
            /// This consists of a field definition line, followed by zero or more comment lines and
            /// continuation lines. The comment lines are dropped. The value in the definition line
            /// and all continuation lines are concatenated with newline characters.
            fn field_definition<'a, E>(input: &'a str) -> IResult<&'a str, Field<'a>, E>
            where
                E: ParseError<&'a str>,
            {
                context(
                    "field definition",
                    map(
                        pair(
                            field_definition_line,
                            many0(alt((continuation_line, comment_line))),
                        ),
                        field_from_parts,
                    ),
                )(input)
            }

            /// Parse a full paragraph.
            ///
            /// This parser first consumes any leading comment and blank lines, followed by one or
            /// more field definitions, followed by either a blank line or (for complete parsers)
            /// EOF.
            pub(crate) fn paragraph<'a, E>(input: &'a str) -> IResult<&'a str, Option<Paragraph>, E>
            where
                E: ParseError<&'a str>,
            {
                preceded(
                    many0_count(alt((blank_line, comment_line))),
                    terminated(
                        opt(map(many1(field_definition), Paragraph::new)),
                        context("paragraph terminator", alt((map(blank_line, |_| ()), eof))),
                    ),
                )(input)
            }
        }
    };
}

parsers!(streaming);
parsers!(complete);

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tests::field;
    use alloc::vec;

    type SimpleError<'a> = (&'a str, ErrorKind);

    mod field_from_parts {
        use super::*;

        #[test]
        fn should_build_field_from_definition_line() {
            let parts = (
                FieldDefinitionLine {
                    name: "field-name",
                    value: "field value",
                },
                vec![],
            );
            let result = field_from_parts(parts);
            assert_eq!(result, field("field-name", "field value"));
        }

        #[test]
        fn should_build_field_from_definition_line_and_continuations() {
            let parts = (
                FieldDefinitionLine {
                    name: "field",
                    value: "value",
                },
                vec![
                    FieldDefinitionContinuation::Continuation("line 2"),
                    FieldDefinitionContinuation::Continuation("line 3"),
                    FieldDefinitionContinuation::Continuation("line 4"),
                    FieldDefinitionContinuation::Continuation("line 5"),
                ],
            );
            let result = field_from_parts(parts);
            assert_eq!(
                result,
                field("field", "value\nline 2\nline 3\nline 4\nline 5")
            );
        }

        #[test]
        fn should_build_field_from_definition_line_and_mixed_continuations_and_comments() {
            let parts = (
                FieldDefinitionLine {
                    name: "combined-field",
                    value: "l1",
                },
                vec![
                    FieldDefinitionContinuation::Continuation("l2"),
                    FieldDefinitionContinuation::Comment,
                    FieldDefinitionContinuation::Comment,
                    FieldDefinitionContinuation::Continuation("l3"),
                    FieldDefinitionContinuation::Comment,
                ],
            );
            let result = field_from_parts(parts);
            assert_eq!(result, field("combined-field", "l1\nl2\nl3"));
        }

        #[test]
        fn should_build_field_from_definition_line_and_only_comments() {
            let parts = (
                FieldDefinitionLine {
                    name: "comment-field",
                    value: "",
                },
                vec![
                    FieldDefinitionContinuation::Comment,
                    FieldDefinitionContinuation::Comment,
                    FieldDefinitionContinuation::Comment,
                ],
            );
            let result = field_from_parts(parts);
            assert_eq!(result, field("comment-field", ""));
        }
    }

    mod eof {
        use super::*;

        #[test]
        fn should_accept_empty_input() {
            let result = eof::<SimpleError>("");
            assert_eq!(result, Ok(("", ())));
        }

        #[test]
        fn should_not_accept_non_empty_input() {
            let result = eof::<SimpleError>("x");
            assert_eq!(result, Err(Error(("x", ErrorKind::Eof))));
        }
    }
}
